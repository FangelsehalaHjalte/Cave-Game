<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cave Game</title>
    <link type="image/x-icon" rel="shortcut icon" href="https://minecraft.wiki/images/Cobblestone_JE1.png?aed6a" />
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #000;
        }
    </style>
</head>
<body>
    <div id="renderDiv"></div>
    <script>
        class MainMenu extends Phaser.Scene {
    constructor() {
        super('MainMenu');
    }

    preload() {
        this.load.image('menuBackground', 'https://play.rosebud.ai/assets/bg.png?29HV');
        this.load.image('orchard', 'https://play.rosebud.ai/assets/rock5.png?mfFS');
        this.load.image('playButton', 'https://play.rosebud.ai/assets/button.png?QMZ6');
        this.load.image('titleImage', 'https://play.rosebud.ai/assets/CAVE-GAME-8-24-2024.png?qImE');
        this.load.image('square', 'https://play.rosebud.ai/assets/player.png?6jwG');
        this.load.audio('menuMusic', 'https://play.rosebud.ai/assets/main menu.mp3?34RN');
        this.load.audio('gameMusic', 'https://play.rosebud.ai/assets/underground (1).mp3?8l13');
        this.load.image('wall', 'https://play.rosebud.ai/assets/cavewall.png?g7hs');
        this.load.image('cursorTexture', 'https://play.rosebud.ai/assets/cursor.png?JWxv');
        this.load.image('healthBar', 'https://play.rosebud.ai/assets/health.png?xrXv');
        this.load.image('zombie', 'https://play.rosebud.ai/assets/zombie.png?rnXs');
        this.load.image('groundSword', 'https://play.rosebud.ai/assets/Sword_(item).png?3VYd');
        this.load.image('swordPickedup', 'https://play.rosebud.ai/assets/Iron_Sword_JE1_BE1.png?7Lca');
        this.load.image('apple', 'https://play.rosebud.ai/assets/Red_apple_(item).png?3bzU');
        this.load.image('leatherArmor', 'https://play.rosebud.ai/assets/Leather_Armor_(item).png?PtDg');
        this.load.image('playerArmored', 'https://play.rosebud.ai/assets/player_armored_1.png?4g3D');
        this.load.image('skele', 'https://play.rosebud.ai/assets/skele.png?Ijlr');
        this.load.audio('hurtSound', 'https://play.rosebud.ai/assets/Hurt_Old.mp3?cern');
        this.load.audio('gameOverSound', 'https://play.rosebud.ai/assets/Hurtflesh3.mp3?x8SF');
    }

    create() {
        // Stop and hide other scenes
        if (this.scene.get('GameScene').scene.isActive()) {
            this.scene.stop('GameScene');
        }
        if (this.scene.get('UIScene').scene.isActive()) {
            this.scene.stop('UIScene');
        }

        const background = this.add.image(400, 300, 'menuBackground');
        const scaleX = 800 / background.width;
        const scaleY = 600 / background.height;
        const scale = Math.max(scaleX, scaleY);
        background.setScale(scale);
        background.setAlpha(0);

        const titleImage = this.add.image(400, 150, 'titleImage');
        titleImage.setOrigin(0.5);
        titleImage.setScale(0.5);
        titleImage.setAlpha(0);

        const playButton = this.add.image(400, 300, 'playButton').setInteractive();
        playButton.setScale(2);
        playButton.setAlpha(0);

        const playText = this.add.text(400, 300, 'Play', {
            fontSize: '20px',
            fill: '#fff'
        }).setOrigin(0.5);
        playText.setAlpha(0);

        playButton.on('pointerdown', () => {
            this.cameras.main.fadeOut(1000, 0, 0, 0);
            this.cameras.main.once(Phaser.Cameras.Scene2D.Events.FADE_OUT_COMPLETE, () => {
                this.sound.stopAll();
                this.scene.start('GameScene');
            });
        });

        // Add Options button
        const optionsButton = this.add.image(400, 400, 'playButton').setInteractive();
        optionsButton.setScale(2);
        optionsButton.setAlpha(0);

        const optionsText = this.add.text(400, 400, 'Options', {
            fontSize: '20px',
            fill: '#fff'
        }).setOrigin(0.5);
        optionsText.setAlpha(0);

        optionsButton.on('pointerdown', () => {
            this.scene.start('OptionsMenu');
        });

        if (!this.music) {
            this.music = this.sound.add('menuMusic', { loop: true, volume: 0 });
        }

        if (!this.sys.game.globals.musicOff) {
            this.music.play();
        }

        // Fade in all visual elements
        this.tweens.add({
            targets: [background, titleImage, playButton, playText, optionsButton, optionsText],
            alpha: 1,
            duration: 2000,
            ease: 'Power2'
        });

        // Fade in the music if it's not off
        if (!this.sys.game.globals.musicOff) {
            this.tweens.add({
                targets: this.music,
                volume: 1,
                duration: 2000,
                ease: 'Linear'
            });
        }

        // Create a custom cursor using the cursor texture
        this.input.setDefaultCursor('none');
        this.customCursor = this.add.image(0, 0, 'cursorTexture').setOrigin(0, 0);
        this.customCursor.setScale(0.5); // Adjust the scale as needed
        this.customCursor.setDepth(1000); // Set a high depth to ensure it's above other elements
        this.input.on('pointermove', (pointer) => {
            this.customCursor.setPosition(pointer.x, pointer.y);
        });
    }
}

class OptionsMenu extends Phaser.Scene {
    constructor() {
        super('OptionsMenu');
    }

    create() {
        const background = this.add.image(400, 300, 'menuBackground');
        const scaleX = 800 / background.width;
        const scaleY = 600 / background.height;
        const scale = Math.max(scaleX, scaleY);
        background.setScale(scale);

        const backButton = this.add.image(400, 500, 'playButton').setInteractive();
        backButton.setScale(2);

        const backText = this.add.text(400, 500, 'Back', {
            fontSize: '20px',
            fill: '#fff'
        }).setOrigin(0.5);

        backButton.on('pointerdown', () => {
            this.scene.start('MainMenu');
        });

        // Add Music toggle button
        const musicButton = this.add.image(400, 300, 'playButton').setInteractive();
        musicButton.setScale(2);

        const musicText = this.add.text(400, 300, this.sys.game.globals.musicOff ? 'Music: Off' : 'Music: On', {
            fontSize: '20px',
            fill: '#fff'
        }).setOrigin(0.5);

        musicButton.on('pointerdown', () => {
            this.sys.game.globals.musicOff = !this.sys.game.globals.musicOff;
            musicText.setText(this.sys.game.globals.musicOff ? 'Music: Off' : 'Music: On');
            if (this.sys.game.globals.musicOff) {
                this.sound.stopAll();
            } else {
                this.sound.play('menuMusic', { loop: true });
            }
        });

        // Create a custom cursor using the cursor texture
        this.input.setDefaultCursor('none');
        this.customCursor = this.add.image(0, 0, 'cursorTexture').setOrigin(0, 0);
        this.customCursor.setScale(0.5);
        this.customCursor.setDepth(1000);
        this.input.on('pointermove', (pointer) => {
            this.customCursor.setPosition(pointer.x, pointer.y);
        });
    }
}

class GameScene extends Phaser.Scene {
    constructor() {
        super('GameScene');
    }

    create() {
        // Fade in effect
        this.cameras.main.fadeIn(1000, 0, 0, 0);

        // Create a repeating background
        const backgroundTexture = this.textures.get('orchard');
        this.backgroundImage = this.add.tileSprite(0, 0, 800, 600, 'orchard');
        this.backgroundImage.setOrigin(0, 0);
        this.backgroundImage.setScale(1);

        this.walls = this.physics.add.staticGroup();
        this.grid = this.generateCaverns();

        this.square = this.physics.add.image(400, 300, 'square');
        this.square.setCollideWorldBounds(false);
        this.physics.add.collider(this.square, this.walls);

        // Clear 2x2 area around player spawn
        this.clearSpawnArea();

        this.cursors = this.input.keyboard.createCursorKeys();
        this.wasdKeys = this.input.keyboard.addKeys({
            up: Phaser.Input.Keyboard.KeyCodes.W,
            down: Phaser.Input.Keyboard.KeyCodes.S,
            left: Phaser.Input.Keyboard.KeyCodes.A,
            right: Phaser.Input.Keyboard.KeyCodes.D
        });

        this.music = this.sound.add('gameMusic', { loop: true });
        if (!this.sys.game.globals.musicOff) {
            this.music.play();
        }

        // Create a custom cursor using the cursor texture
        this.input.setDefaultCursor('none');
        this.customCursor = this.add.image(0, 0, 'cursorTexture').setOrigin(0, 0);
        this.customCursor.setScale(0.5); // Adjust the scale as needed
        this.customCursor.setDepth(1005); // Set the highest depth to ensure it's above all other elements
        this.input.on('pointermove', (pointer) => {
            this.customCursor.setPosition(pointer.x, pointer.y);
        });

        // Create enemy group
        this.enemies = this.physics.add.group();
        this.physics.add.collider(this.enemies, this.walls);
        this.physics.add.collider(this.square, this.enemies, this.handlePlayerEnemyCollision, null, this);

        // Set up enemy spawn timer with increased frequency
        this.enemySpawnTimer = this.time.addEvent({
            delay: 2000, // Try to spawn every 2 seconds (increased from 5 seconds)
            callback: this.trySpawnEnemy,
            callbackScope: this,
            loop: true
        });

        // Create skeleton group
        this.skeletons = this.physics.add.group();
        this.physics.add.collider(this.skeletons, this.walls);
        this.physics.add.collider(this.square, this.skeletons, this.handlePlayerSkeletonCollision, null, this);

        // Set up skeleton spawn timer
        this.skeletonSpawnTimer = this.time.addEvent({
            delay: 3000, // Try to spawn every 3 seconds
            callback: this.trySpawnSkeleton,
            callbackScope: this,
            loop: true
        });

        // Create a separate UI scene for the health bar
        this.scene.launch('UIScene');
        this.UIScene = this.scene.get('UIScene');

        // Set up pause functionality
        this.isPaused = false;
        this.input.keyboard.on('keydown-ESC', this.togglePause, this);

        // Create dimming rectangle and pause text
        this.dimRect = this.add.rectangle(400, 300, 800, 600, 0x000000);
        this.dimRect.setAlpha(0);
        this.dimRect.setDepth(1000); // Set high depth to ensure it's on top of everything

        this.pauseText = this.add.text(400, 300, 'PAUSED', {
            fontSize: '64px',
            fill: '#ffffff'
        }).setOrigin(0.5);
        this.pauseText.setAlpha(0);
        this.pauseText.setDepth(1001); // Set even higher depth to ensure it's on top of the dimming rectangle

        // Add Quit button
        this.quitButton = this.add.image(700, 550, 'playButton').setInteractive();
        this.quitButton.setScale(1.5);
        this.quitButton.setDepth(1002); // Set high depth to ensure it's on top of most elements

        this.quitText = this.add.text(700, 550, 'Quit', {
            fontSize: '20px',
            fill: '#fff'
        }).setOrigin(0.5);
        this.quitText.setDepth(1003);

        this.quitButton.on('pointerdown', () => {
            this.fadeOutAndQuit();
        });

        // Create ground sword group
        this.groundSwords = this.physics.add.staticGroup();

        // Set up ground sword spawn timer
        this.groundSwordSpawnTimer = this.time.addEvent({
            delay: 30000, // Try to spawn every 30 seconds
            callback: this.trySpawnGroundSword,
            callbackScope: this,
            loop: true
        });

        // Initialize the player's sword status and damage
        this.hasSword = false;
        this.playerDamage = 1;

        // Initialize the score
        this.score = 0;

        // Create apple group
        this.apples = this.physics.add.staticGroup();

        // Set up apple spawn timer
        this.appleSpawnTimer = this.time.addEvent({
            delay: 15000, // Try to spawn every 15 seconds
            callback: this.trySpawnApple,
            callbackScope: this,
            loop: true
        });

        // Create leather armor group
        this.leatherArmors = this.physics.add.staticGroup();

        // Set up leather armor spawn timer
        this.leatherArmorSpawnTimer = this.time.addEvent({
            delay: 30000, // Try to spawn every 45 seconds
            callback: this.trySpawnLeatherArmor,
            callbackScope: this,
            loop: true
        });

        // Set up room filling timer
        this.roomTimer = this.time.addEvent({
            delay: 120000, // 2 minutes
            callback: this.startFillingRoom,
            callbackScope: this,
            loop: false
        });

        this.isFillingRoom = false;
        this.filledCells = new Set();

        // Initialize player's armor status and damage reduction
        this.hasArmor = false;
        this.damageReduction = 1; // No damage reduction initially

        // Load hurt sound
        this.hurtSound = this.sound.add('hurtSound');
    }

    clearSpawnArea() {
        const cellSize = 40;
        const playerGridX = Math.floor(this.square.x / cellSize);
        const playerGridY = Math.floor(this.square.y / cellSize);

        for (let y = playerGridY - 1; y <= playerGridY + 1; y++) {
            for (let x = playerGridX - 1; x <= playerGridX + 1; x++) {
                if (this.grid[y] && this.grid[y][x] === 1) {
                    this.grid[y][x] = 0;
                    const wallToRemove = this.walls.getChildren().find(wall => 
                        Math.floor(wall.x / cellSize) === x && Math.floor(wall.y / cellSize) === y
                    );
                    if (wallToRemove) {
                        wallToRemove.destroy();
                    }
                }
            }
        }
    }

    trySpawnGroundSword() {
        if (Math.random() < 0.4) { // 40% chance to spawn a ground sword
            const cellSize = 40;
            const gridWidth = Math.ceil(800 / cellSize);
            const gridHeight = Math.ceil(600 / cellSize);

            let spawnX, spawnY;
            let attempts = 0;
            const maxAttempts = 50;

            do {
                const gridX = Phaser.Math.Between(0, gridWidth - 1);
                const gridY = Phaser.Math.Between(0, gridHeight - 1);

                if (this.grid[gridY] && this.grid[gridY][gridX] === 0) {
                    spawnX = gridX * cellSize + cellSize / 2;
                    spawnY = gridY * cellSize + cellSize / 2;
                    break;
                }

                attempts++;
            } while (attempts < maxAttempts);

            if (spawnX !== undefined && spawnY !== undefined) {
                const groundSword = this.groundSwords.create(spawnX, spawnY, 'groundSword');
                groundSword.setScale(0.1); // Make the ground sword 10x smaller
                groundSword.setInteractive();
                groundSword.on('pointerdown', () => {
                    this.collectGroundSword(groundSword);
                });
            }
        }
    }

    trySpawnApple() {
        if (Math.random() < 0.2) { // 20% chance to spawn an apple
            const cellSize = 40;
            const gridWidth = Math.ceil(800 / cellSize);
            const gridHeight = Math.ceil(600 / cellSize);

            let spawnX, spawnY;
            let attempts = 0;
            const maxAttempts = 50;

            do {
                const gridX = Phaser.Math.Between(0, gridWidth - 1);
                const gridY = Phaser.Math.Between(0, gridHeight - 1);

                if (this.grid[gridY] && this.grid[gridY][gridX] === 0) {
                    spawnX = gridX * cellSize + cellSize / 2;
                    spawnY = gridY * cellSize + cellSize / 2;
                    break;
                }

                attempts++;
            } while (attempts < maxAttempts);

            if (spawnX !== undefined && spawnY !== undefined) {
                const apple = this.apples.create(spawnX, spawnY, 'apple');
                apple.setScale(0.2); // Make the apple 2x bigger (0.1 * 2 = 0.2)
                apple.setInteractive();
                apple.on('pointerdown', () => {
                    this.collectApple(apple);
                });
            }
        }
    }

    trySpawnLeatherArmor() {
        if (Math.random() < 0.1) { // 10% chance to spawn leather armor
            const cellSize = 40;
            const gridWidth = Math.ceil(800 / cellSize);
            const gridHeight = Math.ceil(600 / cellSize);

            let spawnX, spawnY;
            let attempts = 0;
            const maxAttempts = 50;

            do {
                const gridX = Phaser.Math.Between(0, gridWidth - 1);
                const gridY = Phaser.Math.Between(0, gridHeight - 1);

                if (this.grid[gridY] && this.grid[gridY][gridX] === 0) {
                    spawnX = gridX * cellSize + cellSize / 2;
                    spawnY = gridY * cellSize + cellSize / 2;
                    break;
                }

                attempts++;
            } while (attempts < maxAttempts);

            if (spawnX !== undefined && spawnY !== undefined) {
                const leatherArmor = this.leatherArmors.create(spawnX, spawnY, 'leatherArmor');
                leatherArmor.setScale(0.1); // Make the leather armor 10x smaller
                leatherArmor.setInteractive();
                leatherArmor.on('pointerdown', () => {
                    this.collectLeatherArmor(leatherArmor);
                });
            }
        }
    }

    collectGroundSword(groundSword) {
        groundSword.destroy();
        console.log('Ground sword collected!');
        this.hasSword = true;
        this.playerDamage = 4; // Update player damage to 4 points
        this.UIScene.showSwordIcon();
        console.log('Player damage increased to 4!');
    }

    collectApple(apple) {
        apple.destroy();
        console.log('Apple collected!');
        const healAmount = 10; // 10% of max health
        this.UIScene.healPlayer(healAmount);
    }

    collectLeatherArmor(leatherArmor) {
        leatherArmor.destroy();
        console.log('Leather armor collected!');
        this.hasArmor = true;
        this.damageReduction = 0.7; // 30% damage reduction
        this.square.setTexture('playerArmored');
        console.log('Player sprite changed to armored version!');
        console.log('Player now has 30% damage reduction!');
    }

    fadeOutAndQuit() {
        // Fade out all game elements
        this.tweens.add({
            targets: [
                this.backgroundImage,
                this.square,
                ...this.walls.getChildren(),
                ...this.enemies.getChildren(),
                ...this.skeletons.getChildren(),
                ...this.groundSwords.getChildren(),
                ...this.apples.getChildren(),
                ...this.leatherArmors.getChildren(),
                this.customCursor,
                this.dimRect,
                this.pauseText,
                this.quitButton,
                this.quitText
            ],
            alpha: 0,
            duration: 1000,
            ease: 'Power2',
            onComplete: () => {
                // Stop the music
                this.music.stop();
                
                // Start the main menu scene
                this.scene.start('MainMenu');
            }
        });

        // Fade out the music
        this.tweens.add({
            targets: this.music,
            volume: 0,
            duration: 1000,
            ease: 'Linear'
        });

        // Fade out the UI elements
        this.UIScene.fadeOut();
    }

    togglePause() {
        this.isPaused = !this.isPaused;
        if (this.isPaused) {
            // Pause the game
            this.physics.pause();
            this.enemySpawnTimer.paused = true;
            this.skeletonSpawnTimer.paused = true;
            this.groundSwordSpawnTimer.paused = true;
            this.appleSpawnTimer.paused = true;
            this.leatherArmorSpawnTimer.paused = true;
            this.roomTimer.paused = true;
            this.enemies.children.entries.forEach((enemy) => {
                enemy.oldVelocity = enemy.body.velocity.clone();
                enemy.setVelocity(0, 0);
            });
            this.skeletons.children.entries.forEach((skeleton) => {
                skeleton.oldVelocity = skeleton.body.velocity.clone();
                skeleton.setVelocity(0, 0);
            });
            this.square.oldVelocity = this.square.body.velocity.clone();
            this.square.setVelocity(0, 0);

            // Dim the screen and show pause text
            this.tweens.add({
                targets: this.dimRect,
                alpha: 0.7,
                duration: 500
            });
            this.tweens.add({
                targets: this.pauseText,
                alpha: 1,
                duration: 500
            });
        } else {
            // Resume the game
            this.physics.resume();
            this.enemySpawnTimer.paused = false;
            this.skeletonSpawnTimer.paused = false;
            this.groundSwordSpawnTimer.paused = false;
            this.appleSpawnTimer.paused = false;
            this.leatherArmorSpawnTimer.paused = false;
            this.roomTimer.paused = false;
            this.enemies.children.entries.forEach((enemy) => {
                if (enemy.oldVelocity) {
                    enemy.setVelocity(enemy.oldVelocity.x, enemy.oldVelocity.y);
                }
            });
            this.skeletons.children.entries.forEach((skeleton) => {
                if (skeleton.oldVelocity) {
                    skeleton.setVelocity(skeleton.oldVelocity.x, skeleton.oldVelocity.y);
                }
            });
            if (this.square.oldVelocity) {
                this.square.setVelocity(this.square.oldVelocity.x, this.square.oldVelocity.y);
            }

            // Undim the screen and hide pause text
            this.tweens.add({
                targets: this.dimRect,
                alpha: 0,
                duration: 500
            });
            this.tweens.add({
                targets: this.pauseText,
                alpha: 0,
                duration: 500
            });
        }
    }

    handlePlayerEnemyCollision(player, enemy) {
        // Handle collision between player and enemy
        console.log('Player collided with enemy!');
        const damageAmount = 10 * this.damageReduction; // Apply damage reduction
        this.UIScene.takeDamage(damageAmount); // Player takes reduced damage when colliding with an enemy
        
        // Play hurt sound
        this.hurtSound.play();

        // Instead of destroying the enemy, we'll make it bounce off the player
        const angle = Phaser.Math.Angle.Between(player.x, player.y, enemy.x, enemy.y);
        const velocity = new Phaser.Math.Vector2().setToPolar(angle, 100);
        enemy.setVelocity(velocity.x, velocity.y);

        // Add a brief invulnerability period for the player
        player.setTint(0xff0000); // Tint the player red
        player.isInvulnerable = true;
        this.time.delayedCall(1000, () => {
            player.clearTint();
            player.isInvulnerable = false;
        });
    }

    handlePlayerSkeletonCollision(player, skeleton) {
        // Handle collision between player and skeleton
        console.log('Player collided with skeleton!');
        const damageAmount = 5 * this.damageReduction; // Apply damage reduction (5% of player's health)
        this.UIScene.takeDamage(damageAmount); // Player takes reduced damage when colliding with a skeleton
        
        // Play hurt sound
        this.hurtSound.play();

        // Make the skeleton bounce off the player
        const angle = Phaser.Math.Angle.Between(player.x, player.y, skeleton.x, skeleton.y);
        const velocity = new Phaser.Math.Vector2().setToPolar(angle, 100);
        skeleton.setVelocity(velocity.x, velocity.y);

        // Add a brief invulnerability period for the player
        player.setTint(0xff0000); // Tint the player red
        player.isInvulnerable = true;
        this.time.delayedCall(1000, () => {
            player.clearTint();
            player.isInvulnerable = false;
        });
    }

    trySpawnEnemy() {
        if (Math.random() < 0.4) { // Increased chance to spawn an enemy (from 0.2 to 0.4)
            const cellSize = 40;
            const gridWidth = Math.ceil(800 / cellSize);
            const gridHeight = Math.ceil(600 / cellSize);

            let spawnX, spawnY;
            let attempts = 0;
            const maxAttempts = 50;

            do {
                const gridX = Phaser.Math.Between(0, gridWidth - 1);
                const gridY = Phaser.Math.Between(0, gridHeight - 1);

                if (this.grid[gridY] && this.grid[gridY][gridX] === 0) {
                    spawnX = gridX * cellSize + cellSize / 2;
                    spawnY = gridY * cellSize + cellSize / 2;
                    break;
                }

                attempts++;
            } while (attempts < maxAttempts);

            if (spawnX !== undefined && spawnY !== undefined) {
                const enemy = this.enemies.create(spawnX, spawnY, 'zombie');
                enemy.setCollideWorldBounds(true);
                enemy.setInteractive(); // Make the enemy interactive
                enemy.health = 10; // Set enemy health to 10

                // Add click listener to the enemy
                enemy.on('pointerdown', () => {
                    this.damageEnemy(enemy);
                });
                
                // Simple AI: move towards the player
                this.time.addEvent({
                    delay: 1000,
                    callback: () => this.moveEnemyTowardsPlayer(enemy),
                    callbackScope: this,
                    loop: true
                });
            }
        }
    }

    trySpawnSkeleton() {
        if (Math.random() < 0.3) { // 30% chance to spawn a skeleton
            const cellSize = 40;
            const gridWidth = Math.ceil(800 / cellSize);
            const gridHeight = Math.ceil(600 / cellSize);

            let spawnX, spawnY;
            let attempts = 0;
            const maxAttempts = 50;

            do {
                const gridX = Phaser.Math.Between(0, gridWidth - 1);
                const gridY = Phaser.Math.Between(0, gridHeight - 1);

                if (this.grid[gridY] && this.grid[gridY][gridX] === 0) {
                    spawnX = gridX * cellSize + cellSize / 2;
                    spawnY = gridY * cellSize + cellSize / 2;
                    break;
                }

                attempts++;
            } while (attempts < maxAttempts);

            if (spawnX !== undefined && spawnY !== undefined) {
                const skeleton = this.skeletons.create(spawnX, spawnY, 'skele');
                skeleton.setCollideWorldBounds(true);
                skeleton.setInteractive(); // Make the skeleton interactive
                skeleton.health = 5; // Set skeleton health to 5

                // Add click listener to the skeleton
                skeleton.on('pointerdown', () => {
                    this.damageSkeleton(skeleton);
                });
                
                // Simple AI: chase the player
                this.time.addEvent({
                    delay: 500,
                    callback: () => this.moveSkeletonTowardsPlayer(skeleton),
                    callbackScope: this,
                    loop: true
                });
            }
        }
    }

    damageEnemy(enemy) {
        enemy.health -= this.playerDamage; // Apply player's current damage
        if (enemy.health <= 0) {
            enemy.destroy();
            this.score += 10; // Increase score by 10 when an enemy is killed
            this.UIScene.updateScore(this.score); // Update the score display
        } else {
            // Visual feedback for damage (you can improve this)
            this.tweens.add({
                targets: enemy,
                alpha: 0.5,
                yoyo: true,
                duration: 100
            });
        }
    }

    damageSkeleton(skeleton) {
        skeleton.health -= this.playerDamage; // Apply player's current damage
        if (skeleton.health <= 0) {
            skeleton.destroy();
            this.score += 5; // Increase score by 5 when a skeleton is killed
            this.UIScene.updateScore(this.score); // Update the score display
        } else {
            // Visual feedback for damage (you can improve this)
            this.tweens.add({
                targets: skeleton,
                alpha: 0.5,
                yoyo: true,
                duration: 100
            });
        }
    }

    moveEnemyTowardsPlayer(enemy) {
        if (enemy.active && !this.isPaused) {
            this.physics.moveToObject(enemy, this.square, 50);
        }
    }

    moveSkeletonTowardsPlayer(skeleton) {
        if (skeleton.active && !this.isPaused) {
            this.physics.moveToObject(skeleton, this.square, 50);
        }
    }

    generateCaverns() {
        this.walls.clear(true, true);
        const cellSize = 40;
        const gridWidth = Math.ceil(800 / cellSize);
        const gridHeight = Math.ceil(600 / cellSize);
        const fillProbability = 0.4;

        let grid = [];
        for (let y = 0; y < gridHeight; y++) {
            grid[y] = [];
            for (let x = 0; x < gridWidth; x++) {
                grid[y][x] = Math.random() < fillProbability ? 1 : 0;
            }
        }

        for (let i = 0; i < 5; i++) {
            grid = this.smoothMap(grid);
        }

        // Ensure at least one opening
        let hasOpening = false;
        for (let y = 0; y < gridHeight; y++) {
            if (grid[y][0] === 0) {
                hasOpening = true;
                break;
            }
        }
        if (!hasOpening) {
            let randomY = Phaser.Math.Between(0, gridHeight - 1);
            grid[randomY][0] = 0;
        }

        for (let y = 0; y < gridHeight; y++) {
            for (let x = 0; x < gridWidth; x++) {
                if (grid[y][x] === 1) {
                    this.walls.create(x * cellSize + cellSize / 2, y * cellSize + cellSize / 2, 'wall')
                        .setScale(cellSize / 32)
                        .refreshBody();
                }
            }
        }

        return grid;
    }

    smoothMap(grid) {
        const newGrid = JSON.parse(JSON.stringify(grid));
        for (let y = 0; y < grid.length; y++) {
            for (let x = 0; x < grid[y].length; x++) {
                let neighbors = this.countAliveNeighbors(grid, x, y);
                if (grid[y][x] === 1) {
                    if (neighbors < 4) newGrid[y][x] = 0;
                } else {
                    if (neighbors > 4) newGrid[y][x] = 1;
                }
            }
        }
        return newGrid;
    }

    countAliveNeighbors(grid, x, y) {
        let count = 0;
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                let neighbor_x = x + i;
                let neighbor_y = y + j;
                if (i === 0 && j === 0) continue;
                if (neighbor_x < 0 || neighbor_y < 0 || neighbor_y >= grid.length || neighbor_x >= grid[0].length) {
                    count++;
                } else if (grid[neighbor_y][neighbor_x] === 1) {
                    count++;
                }
            }
        }
        return count;
    }

    startFillingRoom() {
        this.isFillingRoom = true;
        this.filledCells.clear();
        this.time.addEvent({
            delay: 500, // Add a new wall tile every 500ms
            callback: this.addRandomWallTile,
            callbackScope: this,
            loop: true
        });
    }

    addRandomWallTile() {
        if (!this.isFillingRoom) return;

        const cellSize = 40;
        const gridWidth = Math.ceil(800 / cellSize);
        const gridHeight = Math.ceil(600 / cellSize);

        let attempts = 0;
        const maxAttempts = 50;

        while (attempts < maxAttempts) {
            const x = Phaser.Math.Between(0, gridWidth - 1);
            const y = Phaser.Math.Between(0, gridHeight - 1);

            if (this.grid[y][x] === 0 && !this.filledCells.has(`${x},${y}`)) {
                this.grid[y][x] = 1;
                this.walls.create(x * cellSize + cellSize / 2, y * cellSize + cellSize / 2, 'wall')
                    .setScale(cellSize / 32)
                    .refreshBody();
                this.filledCells.add(`${x},${y}`);
                break;
            }

            attempts++;
        }

        if (this.filledCells.size >= gridWidth * gridHeight) {
            this.isFillingRoom = false;
        }
    }

    update() {
        if (this.isPaused) return;

        const speed = 200;

        // Check for WASD keys
        if (this.wasdKeys.left.isDown || this.cursors.left.isDown) {
            this.square.setVelocityX(-speed);
        } else if (this.wasdKeys.right.isDown || this.cursors.right.isDown) {
            this.square.setVelocityX(speed);
        } else {
            this.square.setVelocityX(0);
        }

        if (this.wasdKeys.up.isDown || this.cursors.up.isDown) {
            this.square.setVelocityY(-speed);
        } else if (this.wasdKeys.down.isDown || this.cursors.down.isDown) {
            this.square.setVelocityY(speed);
        } else {
            this.square.setVelocityY(0);
        }

        //Check if the player is at the edge of the screen
        if (this.square.x < 0) {
            this.square.x = 800;
            this.regenerateLevel('left');
        } else if (this.square.x > 800) {
            this.square.x = 0;
            this.regenerateLevel('right');
        }

        if (this.square.y < 0) {
            this.square.y = 600;
            this.regenerateLevel('top');
        } else if (this.square.y > 600) {
            this.square.y = 0;
            this.regenerateLevel('bottom');
        }
    }

    regenerateLevel(direction) {
        // Despawn all enemies, skeletons, ground swords, apples, and leather armors
        this.enemies.clear(true, true);
        this.skeletons.clear(true, true);
        this.groundSwords.clear(true, true);
        this.apples.clear(true, true);
        this.leatherArmors.clear(true, true);

        const cellSize = 40;
        this.grid = this.generateCaverns();
        let newX, newY;
        let attempts = 0;
        const maxAttempts = 100;

        switch(direction) {
            case 'left':
                newX = 790;
                newY = this.square.y;
                break;
            case 'right':
                newX =  10;
                newY = this.square.y;
                break;
            case 'top':
                newX = this.square.x;
                newY = 590;
                break;
            case 'bottom':
                newX = this.square.x;
                newY = 10;
                break;
        }

        while (attempts < maxAttempts) {
            const gridX = Math.floor(newX / cellSize);
            const gridY = Math.floor(newY / cellSize);

            if (this.grid[gridY] && this.grid[gridY][gridX] === 0) {
                // Found an open space
                this.square.setPosition(newX, newY);
                this.clearSpawnArea(); // Clear the area around the new spawn point
                break;
            }

            // Adjust position slightly and try again
            newX += Phaser.Math.Between(-20, 20);
            newY += Phaser.Math.Between(-20, 20);

            // Keep within bounds
            newX = Phaser.Math.Clamp(newX, 10, 790);
            newY = Phaser.Math.Clamp(newY, 10, 590);

            attempts++;
        }

        if (attempts >= maxAttempts) {
            // If we couldn't find an open space, just place the player at the center
            this.square.setPosition(400, 300);
            this.clearSpawnArea(); // Clear the area around the center spawn point
        }

        // Reset the room filling timer
        this.roomTimer.reset({
            delay: 120000,
            callback: this.startFillingRoom,
            callbackScope: this,
            loop: false
        });

        this.isFillingRoom = false;
        this.filledCells.clear();
    }
}

class UIScene extends Phaser.Scene {
    constructor() {
        super('UIScene');
    }

    create() {
        // Add health bar
        this.healthBar = this.add.image(400, 30, 'healthBar');
        this.healthBar.setOrigin(0.5, 0.5);
        this.healthBar.setScale(2, 1);
        this.playerHealth = 100;

        // Add health text
        this.healthText = this.add.text(400, 30, `${this.playerHealth}%`, {
            fontSize: '24px',
            fill: '#ffffff'
        }).setOrigin(0.5, 0.5);

        //Add sword icon (initially hidden)
        this.swordIcon = this.add.image(100, 500, 'swordPickedup');
        this.swordIcon.setOrigin(0.5);
        this.swordIcon.setScale(0.25); // Make the sword icon 10x smaller (2.5 / 10)
        this.swordIcon.setVisible(false);

        // Add score text
        this.scoreText = this.add.text(400, 60, 'Score: 0', {
            fontSize: '24px',
            fill: '#ffffff'
        }).setOrigin(0.5, 0);

        // Add game over elements (initially hidden)
        this.gameOverRect = this.add.rectangle(400, 300, 800, 600, 0x000000);
        this.gameOverRect.setAlpha(0);
        this.gameOverRect.setDepth(1000);

        this.gameOverText = this.add.text(400, 300, 'You have been Slain...', {
            fontSize: '48px',
            fill: '#ffffff'
        }).setOrigin(0.5);
        this.gameOverText.setAlpha(0);
        this.gameOverText.setDepth(1001);

        // Load hurt sound
        this.hurtSound = this.sound.add('hurtSound');

        // Load game over sound
        this.gameOverSound = this.sound.add('gameOverSound');
    }

    takeDamage(amount) {
        this.playerHealth -= amount;
        this.playerHealth = Math.max(0, this.playerHealth); // Ensure health doesn't go below 0
        this.updateHealthBar();

        // Play hurt sound
        this.hurtSound.play();

        if (this.playerHealth <= 0) {
            this.gameOver();
        }
    }

    healPlayer(amount) {
        this.playerHealth = Math.min(100, this.playerHealth + amount); // Ensure health doesn't go above 100
        this.updateHealthBar();
    }

    updateHealthBar() {
        // Update health bar scale
        const healthScale = this.playerHealth / 100;
        this.healthBar.setScale(2 * healthScale, 1);

        // Update health text
        this.healthText.setText(`${this.playerHealth}%`);
    }

    showSwordIcon() {
        this.swordIcon.setVisible(true);
    }

    updateScore(score) {
        this.scoreText.setText(`Score: ${score}`);
    }

    fadeOut() {
        this.tweens.add({
            targets: [this.healthBar, this.healthText, this.swordIcon, this.scoreText],
            alpha: 0,
            duration: 1000,
            ease: 'Power2'
        });
    }

    gameOver() {
        // Pause the game
        const gameScene = this.scene.get('GameScene');
        gameScene.isPaused = true;
        gameScene.physics.pause();

        // Stop the music
        gameScene.music.stop();

        // Play game over sound once
        this.gameOverSound.play();

        // Show game over screen
        this.tweens.add({
            targets: [this.gameOverRect, this.gameOverText],
            alpha: 1,
            duration: 1000,
            ease: 'Power2',
            onComplete: () => {
                // Wait for 3 seconds before returning to the main menu
                this.time.delayedCall(3000, () => {
                    this.scene.start('MainMenu');
                });
            }
        });
    }
}

const container = document.getElementById('renderDiv');
const config = {
    type: Phaser.AUTO,
    parent: 'renderDiv',
    pixelArt: true,
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
    },
    width: 800,
    height: 600,
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 0 }
        }
    },
    scene: [MainMenu, OptionsMenu, GameScene, UIScene]
};

window.phaserGame = new Phaser.Game(config);

// Add a global variable to track music state, default to false (music on)
window.phaserGame.globals = { musicOff: false };
    </script>
</body>
</html>
